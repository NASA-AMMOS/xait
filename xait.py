#! /usr/bin/env python3
#
# xait.py
#
# Translates an AIT command dictionary yaml file into an AMPCS
# xml file for use by Aerie Editor when creating seq.json.
#
# The generated xml file is almost certainly not fully compliant
# to the AMPCS spec but it really only meant to be loaded by
# Aerie editor.
#
# To install required packages:
# yaml: pip3 install pyyaml
#

import os
import re
import argparse
import xml.etree.ElementTree as ET
import sys

try:
    import yaml
except:
    print("Failed to load yaml module. Install with:", file=sys.stderr)
    print("   pip3 install pyyaml", file=sys.stderr)
    exit(1)

VERSION='1.0'
ITAR_WARNING = \
'''
The technical data in the generated document is controlled under the U.S. Export Regulations;
release to foreign persons may require an export authorization.  Controlled Unclassified
Information (CUI); Sensitive But Unclassified Information (SBU); or For Official Use Only (FOUO)
'''

WARNING = 'File generated by xait.py. MAY NOT BE FULLY COMPLIANT WITH AMPCS XML.'

# map for types other than string and enum
# strings are handled with a regex
# enums need special handling
TYPE_MAP = {
# unsigned ints
    "U8":      "unsigned_arg",
    "MSB_U16": "unsigned_arg",
    "MSB_U32": "unsigned_arg",
    "MSB_U64": "unsigned_arg",
    "LSB_U16": "unsigned_arg",
    "LSB_U32": "unsigned_arg",
    "LSB_U64": "unsigned_arg",
# signed ints
    "I8":      "integer_arg",
    "MSB_I16": "integer_arg",
    "MSB_I32": "integer_arg",
    "MSB_I64": "integer_arg",
    "LSB_I16": "integer_arg",
    "LSB_I32": "integer_arg",
    "LSB_I64": "integer_arg",
# floats and doubles
    "MSB_F32": "float_arg",
    "LSB_F32": "float_arg",
    "MSB_D64": "float_arg",
    "LSB_D64": "float_arg"
}

ENUM_TABLE_NAMES = {} # dictionary to keep track of enum tables

WRITE_COMMENTS = False
KEEP_FIXED = False

#
# recursively load command dictionary files, handling !include
def load_cmds(fname):
    cmds = []
    with open(fname, 'r') as yf:
        ait_cmds = yaml.load(yf, Loader=yaml.BaseLoader)

    for ait_cmd in ait_cmds:
        # These are the !Command directives
        if type(ait_cmd) == dict:
            cmds.append(ait_cmd)

        # These are the !Include directives
        elif type(ait_cmd) == str:
            # figure out relative path of this file
            path = os.path.dirname(fname)

            # make sure it ends in a /
            if len(path) > 0 and path[-1] != '/':
                path = path + '/'

            # recursively load include files
            cs = load_cmds(path + ait_cmd)

            # add included cmds to our list
            cmds.extend(cs)
        else:
            print('Found unexpected type in ait yaml stream: ' + str(type(ait_cmd)))
            exit(1)

    return cmds

#
# lookup or add enum table for the given enum arg
#
def add_enum_table(enum_def_el, arg):
    # convert the whole enum table to a string
    # lookup by this string value to eliminate duplicate tables
    s = str(arg['enum'])
    if s not in ENUM_TABLE_NAMES:
        etel = ET.SubElement(enum_def_el, 'enum_table')
        valel = ET.SubElement(etel, 'values')
        etname = 'ENUM_' + str(len(ENUM_TABLE_NAMES))
        etel.set('name', etname)

        # iterate over the keys in the enum dict.
        # the keys are the value part of the enum
        enumdict = arg['enum']
        for enumvalue in enumdict.keys():
            enumel = ET.SubElement(valel, 'enum')
            enumel.set('symbol', enumdict[enumvalue])
            enumel.set('numeric', enumvalue)
        ENUM_TABLE_NAMES[s] = etname
    return ENUM_TABLE_NAMES[s]
    
#
# add range values
def add_range(el, arg):
    if 'range' in arg:
        ra = arg['range']
        rovel = ET.SubElement(el, 'range_of_values')
        incel = ET.SubElement(rovel, 'include')
        incel.set('min', ra[0])
        incel.set('max', ra[1])

#
# add comment elements
def add_comment(el, comment):
    # Aerie editor doesn't like comments...
    if WRITE_COMMENTS:
        el.append(ET.Comment(comment))
    return

#
# add description
def add_desc(el, arg_or_cmd):
    if 'desc' in arg_or_cmd:
        desc = ET.SubElement(el, 'description')
        desc.text = arg_or_cmd['desc']

#
# get the bit length by looking at the bytes value in arg
def get_bit_length(arg):
    if 'bytes' not in arg:
        print('expected bytes field in arg ' + arg['name'])
        exit(1)
    b = arg['bytes']
    nb = 1 if type(b) != list else int(b[1])-int(b[0])+1
    return str(nb*8)

#
# add an argument to the command arguments element
# this is where we look at the types to figure out
# the type of element to add
def add_arg(argsel, arg, enum_def_el, fixed_str):
    tname = arg['type']
    el = None

    # fixed args
    if 'value' in arg:
        if not KEEP_FIXED:
            add_comment(argsel, 'Fixed arg:' +
                ' name=' + arg['name'] +
                ' type=' + tname +
                ' value=' + arg['value'])
            return

    # enums
    if 'enum' in arg:
        el = ET.SubElement(argsel, 'enum_arg')
        ename = add_enum_table(enum_def_el, arg)
        el.set('enum_name', ename)
        el.set('bit_length', get_bit_length(arg))

    # strings
    elif re.match('^S[1-9][0-9]*$', tname) != None:
        if fixed_str:
            el = ET.SubElement(argsel, 'fixed_string_arg')
            el.set('bit_length', get_bit_length(arg))
        else:
            el = ET.SubElement(argsel, 'var_string_arg')
            el.set('max_bit_length', get_bit_length(arg))

    # check the type map
    elif tname in TYPE_MAP:
        el = ET.SubElement(argsel, TYPE_MAP[tname])
        el.set('bit_length', get_bit_length(arg))

    # unknown type just handle as a var_string_arg for now
    if el is None:
        print('WARNING: unknown type ' + tname + ' will be handled as var_string_arg')
        el = ET.SubElement(argsel, 'var_string_arg')
        el.set('max_bit_length', get_bit_length(arg))

    el.set('name', arg['name'])
    el.set('units', arg['units'])
    if 'value' in arg:
        el.set('default_value', arg['value'])

    add_comment(el, 'AIT type name ' + tname)
    add_desc(el, arg)
    add_range(el, arg)

    return

#
#
def add_cat(cats,cmd,catname):
    if catname in cmd:
        el = ET.SubElement(cats, 'category')
        el.set('name', catname)
        el.set('value', cmd[catname])
    return

#
# add cmd to command dictionary
def add_cmd(cdel, cmd, enum_def_el, fixed_str):
    if 'arguments' in cmd :
        sc = ET.SubElement(cdel, 'fsw_command')
        sc.set('class', 'FSW')
    else:
        sc = ET.SubElement(cdel, 'hw_command')

    sc.set('opcode', cmd['opcode'])
    sc.set('stem', cmd['name'])

    if 'level' in cmd or 'type' in cmd or 'subsystem' in cmd:
        cats = ET.SubElement(sc, 'categories')
        add_cat(cats,cmd,'level')
        add_cat(cats,cmd,'type')
        add_cat(cats,cmd,'subsystem')

    add_desc(sc, cmd)

    if 'arguments' in cmd :
        # process each arg
        argsel = ET.SubElement(sc, 'arguments')
        for arg in cmd['arguments']:
            add_arg(argsel, arg, enum_def_el, fixed_str)

    return

#
# add header to command dictionary
def add_header(root, mission_name, version, schema_version, scid):
    hel = ET.SubElement(root, 'header')
    hel.set('mission_name', mission_name)
    hel.set('version', version)
    hel.set('schema_version', schema_version)
    scidsel = ET.SubElement(hel, 'spacecraft_ids')
    scidel = ET.SubElement(scidsel, 'spacecraft_id')
    scidel.set('value', str(scid));

def write_command_dictionary(root, ofname):
    with open(ofname, 'wb') as of:
        if sys.version_info >= (3,9):
            ET.indent(root, space='  ', level=0) # to make pretty

        if sys.version_info >= (3,8):
            of.write(ET.tostring(root, encoding='UTF-8', xml_declaration=True))
        else:
            of.write(ET.tostring(root, encoding='UTF-8'))

        of.write(b'\n')

def main():
    # process arguments
    print("xait.py version " + VERSION, file=sys.stderr)
    argparser = argparse.ArgumentParser()
    argparser.add_argument('-f', '--fixed', action='store_true', help="use fixed width strings for S### types")
    argparser.add_argument('-m', '--mission', type=str, default='UNKNOWN', help='mission name')
    argparser.add_argument('-i', '--scid', type=str, default='0', help='spacecraft id')
    argparser.add_argument('-v', '--version', type=str, default='0.0.1', help='version of the command dictionary')
    argparser.add_argument('-s', '--schema_version', type=str, default='0.0.1', help='schema version of the command dictionary')
    argparser.add_argument('-c', '--comments', action='store_true', help='include comments in output (may make the xml unuseable)')
    argparser.add_argument('-k', '--keepfixed', action='store_true', help='keep fixed value args as default_value')
    argparser.add_argument('input_yaml', help="file name of the AIT yaml command dictionary")
    argparser.add_argument('output_xml', help="name for the output xml file")
    args = argparser.parse_args()

    global WRITE_COMMENTS, KEEP_FIXED

    WRITE_COMMENTS = args.comments
    KEEP_FIXED = args.keepfixed

    # load the AIT command dictionary
    aitcmds = load_cmds(args.input_yaml)

    # create a root node for the xml command dictionary
    root = ET.Element('command_dictionary')
    add_comment(root, WARNING)

    # add header/version information
    add_header(root, args.mission, args.version, args.schema_version, args.scid)

    # get nodes for enum and command definitions
    enum_def_el = ET.SubElement(root, 'enum_definitions')
    cdel = ET.SubElement(root, 'command_definitions')

    # iterate over commands in the ait command dictionary
    # and add elements to the xml doc
    for cmd in aitcmds:
        add_cmd(cdel, cmd, enum_def_el, args.fixed)

    # write the xml doc
    write_command_dictionary(root, args.output_xml)
    print(ITAR_WARNING, file=sys.stderr)

    return

if __name__ == '__main__' : main()
