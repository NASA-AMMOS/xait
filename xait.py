#! /usr/bin/env python3
#
# xait.py
#
# Translates an AIT command dictionary yaml file into an AMPCS
# xml file for use by Aerie Editor when creating seq.json.
#
# The generated xml file is almost certainly not fully compliant
# to the AMPCS spec but it really only meant to be loaded by
# Aerie editor.
#
# To install required packages:
# yaml: pip3 install pyyaml
#

import os
import re
import yaml
import argparse
import xml.etree.ElementTree as ET

WARNING = 'File generated by xait.py. NOT FULLY COMPLIANT WITH AMPCS XML'
ENUM_TABLE_NAMES = {} # dictionary to keep track of enum tables

#
# recursively load command dictionary files, handling !include
def load_cmds(fname):
    cmds = []
    with open(fname, 'r') as yf:
        ait_cmds = yaml.load(yf, Loader=yaml.BaseLoader)

    for ait_cmd in ait_cmds:
        # These are the !Command directives
        if type(ait_cmd) == dict:
            cmds.append(ait_cmd)

        # These are the !Include directives
        elif type(ait_cmd) == str:
            # figure out relative path of this file
            path = os.path.dirname(fname)

            # make sure it ends in a /
            if len(path) > 0 and path[-1] != '/':
                path = path + '/'

            # recursively load include files
            cs = load_cmds(path + ait_cmd)

            # add included cmds to our list
            cmds.extend(cs)
        else:
            print('Found unexpected type in ait yaml stream: ' + str(type(ait_cmd)))
            exit(1)

    return cmds

#
# lookup or add enum table for the given enum arg
#
def add_enum_table(enum_def_el, arg):
    # convert the whole enum table to a string
    # lookup by this string value to eliminate duplicate tables
    s = str(arg['enum'])
    if s not in ENUM_TABLE_NAMES:
        etel = ET.SubElement(enum_def_el, 'enum_table')
        valel = ET.SubElement(etel, 'values')
        etname = 'enum_' + str(len(ENUM_TABLE_NAMES))
        etel.set('name', etname)

        # iterate over the keys in the enum dict.
        # the keys are the value part of the enum
        enumdict = arg['enum']
        for enumvalue in enumdict.keys():
            enumel = ET.SubElement(valel, 'enum')
            enumel.set('symbol', enumdict[enumvalue])
            enumel.set('numeric', enumvalue)
        ENUM_TABLE_NAMES[s] = etname
    return ENUM_TABLE_NAMES[s]
    
#
# add range values
def add_range(el, arg):
    if 'range' in arg:
        ra = arg['range']
        rovel = ET.SubElement(el, 'range_of_values')
        incel = ET.SubElement(rovel, 'include')
        incel.set('min', ra[0])
        incel.set('max', ra[1])

#
# add comment elements
def add_comment(el, comment):
    el.append(ET.Comment(comment))

#
# add description
def add_desc(el, arg_or_cmd):
    if 'desc' in arg_or_cmd:
        desc = ET.SubElement(el, 'description')
        desc.text = arg_or_cmd['desc']

#
# set the bit length by looking at the bytes value in arg
def set_bit_length(el, arg):
    if 'bytes' not in arg:
        print('expected bytes field in arg ' + arg['name'])
        exit(1)
    b = arg['bytes']
    nb = 1 if type(b) != list else int(b[1])-int(b[0])+1
    el.set('bit_length', str(nb*8))

#
# add an argument to the command arguments element
# this is where we look at the types to figure out
# the type of element to add
def add_arg(argsel, arg, enum_def_el):
    tname = arg['type']
    el = None

    # fixed args
    if 'value' in arg:
        # TODO:
        # do we skip fixed args?
        add_comment('Fixed arg:' +
            ' name=' + arg['name'] +
            ' type=' + tname +
            ' value=' + arg['value'])
        return

    # enums
    if 'enum' in arg:
        el = ET.SubElement(argsel, 'enum_arg')
        ename = add_enum_table(enum_def_el, arg)
        el.set('enum_name', ename)

    # strings
    elif re.match('^S[0-9]+$', tname) != None:
        el = ET.SubElement(argsel, 'fixed_string_arg')

    # unsigned ints
    elif (tname == 'U8' or
          tname == 'MSB_U16' or tname == 'LSB_U16' or
          tname == 'MSB_U32' or tname == 'LSB_U32' or
          tname == 'MSB_U64' or tname == 'LSB_U64'):
        el = ET.SubElement(argsel, 'unsigned_arg')

    # signed ints
    elif (tname == 'I8' or
          tname == 'MSB_I16' or tname == 'LSB_I16' or
          tname == 'MSB_I32' or tname == 'LSB_I32' or
          tname == 'MSB_I64' or tname == 'LSB_I64'):
        el = ET.SubElement(argsel, 'integer_arg')

    # float
    elif tname == 'MSB_F32' or tname == 'LSB_F32':
        el = ET.SubElement(argsel, 'float_arg')

    # double
    elif tname == 'MSB_D64' or tname == 'LSB_D64':
        el = ET.SubElement(argsel, 'float_arg')

    # unknown type just handle as a var_string_arg for now
    if el is None:
        el = ET.SubElement(argsel, 'var_string_arg')
    else:
        set_bit_length(el, arg)

    el.set('name', arg['name'])
    el.set('units', arg['units'])
    add_comment(el, 'AIT type name ' + tname)
    add_desc(el, arg)
    add_range(el, arg)

    return

#
# add cmd to command dictionary
def add_cmd(cdel, cmd, enum_def_el):
    # TODO:
    # should any be hw_command?
    # hw_commands appear to not have any args
    sc = ET.SubElement(cdel, 'fsw_command')
    sc.set('class', 'FSW')
    sc.set('opcode', cmd['opcode'])
    sc.set('stem', cmd['name'])

    add_desc(sc, cmd)

    # process each arg
    argsel = ET.SubElement(sc, 'arguments')
    for arg in cmd['arguments']:
        add_arg(argsel, arg, enum_def_el)

#
# add header to command dictionary
def add_header(root, mission_name, version, scid):
    hel = ET.SubElement(root, 'header')
    hel.set('mission_name', mission_name)
    hel.set('version', version)
    hel.set('schema_version', '1.0')
    scidsel = ET.SubElement(hel, 'spacecraft_ids')
    scidel = ET.SubElement(scidsel, 'spacecraft_id')
    scidel.set('value', str(scid));

def write_command_dictionary(root, ofname):
    with open(ofname, 'wb') as of:
        ET.indent(root, space='  ', level=0) # to make pretty
        of.write(ET.tostring(root, encoding='UTF-8', xml_declaration=True))
        of.write(b'\n')

def main():
    argparser = argparse.ArgumentParser()
    argparser.add_argument('-m', '--mission', type=str, default='UNKNOWN', help='mission name')
    argparser.add_argument('-i', '--scid', type=int, default=0, help='spacecraft id')
    argparser.add_argument('-v', '--version', type=str, default='0.0.1', help='version of the command dictionary')
    argparser.add_argument('input_yaml', help="file name of the AIT yaml command dictionary")
    argparser.add_argument('output_xml', help="name for the output xml file")

    args = argparser.parse_args()

    aitcmds = load_cmds(args.input_yaml)

    root = ET.Element('command_dictionary')
    add_comment(root, WARNING)
    add_header(root, args.mission, args.version, args.scid)

    enum_def_el = ET.SubElement(root, 'enum_definitions')
    cdel = ET.SubElement(root, 'command_definitions')

    for cmd in aitcmds:
        add_cmd(cdel, cmd, enum_def_el)

    write_command_dictionary(root, args.output_xml)

    return

if __name__ == '__main__' : main()
